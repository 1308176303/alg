#include <iostream>
#include <cstring>

using namespace std;

const int flag = 1000000007;

/*
解题思路：动态规划
这是一道经典的动态规划问题，类似于"解码方法"问题。

问题分析：
1. 给定一个包含数字和'*'的字符串，需要计算有多少种解码方法
2. 数字1-26分别对应字母A-Z
3. '*'可以代表1-9中的任意一个数字
4. 每个字符可以单独解码，相邻两个字符也可能组合解码

状态定义：
dp[i] 表示字符串前i个字符的解码方法总数

状态转移：
对于每个位置i，有两种解码方式：
1. 单字符解码：第i个字符单独解码成一个字母
2. 双字符解码：第i-1和第i个字符组合解码成一个字母

关键难点：
处理'*'字符的所有可能性，需要分情况讨论：
- 单个'*'：可以是1-9，共9种可能
- 两个具体数字：判断是否在10-26范围内
- 一个数字+一个'*'：根据数字确定'*'的可能取值
- 两个'*'：计算所有有效的两位数组合
*/

int main() {
    char s[100005];
    cin >> s;
    int n = strlen(s);
    
    // 边界情况：空字符串
    if (n == 0) {
        cout << 0 << endl;
        return 0;
    }
    
    // dp[i]表示前i个字符的解码方法数
    long long dp[100001];
    dp[0] = 1; // 空字符串有1种解码方法（什么都不解码）
    
    /*
    初始化第一个字符的解码方法数：
    - 如果是'*'：可以是1-9，共9种方法
    - 如果是'0'：无法单独解码，0种方法  
    - 如果是1-9：可以单独解码，1种方法
    */
    if (s[0] == '*') {
        dp[1] = 9; // *可以是1-9
    } else if (s[0] == '0') {
        dp[1] = 0; // 0不能单独解码
    } else {
        dp[1] = 1; // 1-9可以单独解码
    }
    
    // 动态规划主循环：处理第2个到第n个字符
    for (int i = 2; i <= n; i++) {
        dp[i] = 0; // 初始化当前位置的解码方法数
        
        /*
        情况1：当前字符单独解码
        需要判断当前字符是否可以单独解码成一个字母
        */
        if (s[i-1] == '*') {
            // 当前字符是'*'：可以是1-9，每种选择都基于前面的解码方法
            // 所以总方法数 = 9 * dp[i-1]
            dp[i] = (dp[i] + 9 * dp[i-1]) % flag;
        } else if (s[i-1] != '0') {
            // 当前字符是1-9：可以单独解码，继承前面的所有解码方法
            dp[i] = (dp[i] + dp[i-1]) % flag;
        }
        // 注意：如果当前字符是'0'，不能单独解码，所以不加任何贡献
        
        /*
        情况2：当前字符和前一个字符组合解码
        需要判断相邻两个字符组成的数字是否在10-26范围内
        由于有'*'的存在，需要分4种情况讨论
        */
        char prechar = s[i-2];  // 前一个字符
        char curchar = s[i-1];  // 当前字符

        // 情况2.1：两个具体数字 (XY形式，如"12", "25"等)
        if (prechar != '*' && curchar != '*') {
            // 计算两位数的值
            int num = (prechar - '0') * 10 + (curchar - '0');
            // 只有在10-26范围内才能解码成一个字母
            if (num >= 10 && num <= 26) {
                // 跳过前一个字符，基于i-2位置的解码方法数
                dp[i] = (dp[i] + dp[i-2]) % flag;
            }
        } 
        // 情况2.2：第一个字符确定，第二个是* (X*形式，如"1*", "2*")
        else if (prechar != '*' && curchar == '*') {
            if (prechar == '1') {
                // "1*"：*可以是1-9，形成11-19，共9种有效组合
                dp[i] = (dp[i] + 9 * dp[i-2]) % flag;
            } else if (prechar == '2') {
                // "2*"：*可以是1-6，形成21-26，共6种有效组合
                // (27,28,29超出26，不能解码)
                dp[i] = (dp[i] + 6 * dp[i-2]) % flag;
            }
            // 如果prechar是3-9，无法形成有效的两位数（30+都超出26）
        }
        // 情况2.3：第一个是*，第二个字符确定 (*X形式，如"*3", "*8")
        else if (prechar == '*' && curchar != '*') {
            if (curchar >= '0' && curchar <= '6') {
                // "*0"到"*6"：*可以是1或2，形成1X或2X，共2种可能
                // 例如"*3"可以是"13"或"23"
                dp[i] = (dp[i] + 2 * dp[i-2]) % flag;
            } else if (curchar >= '7' && curchar <= '9') {
                // "*7"到"*9"：*只能是1，形成1X，共1种可能
                // 例如"*8"只能是"18"(因为"28"超出26)
                dp[i] = (dp[i] + dp[i-2]) % flag;
            }
            // 注意：curchar不会是'*'，因为我们在这个分支中
        }
        // 情况2.4：两个都是* (**形式)
        else if (prechar == '*' && curchar == '*') {
            // "**"的所有有效组合：
            // 第一个*=1：第二个*可以是1-9 → 11,12,13,14,15,16,17,18,19 (9种)
            // 第一个*=2：第二个*可以是1-6 → 21,22,23,24,25,26 (6种)
            // 总共：9 + 6 = 15种有效组合
            dp[i] = (dp[i] + 15 * dp[i-2]) % flag;
        }
    }
    
    // 输出结果：前n个字符的解码方法总数
    cout << dp[n] << endl;
    return 0;
}

/*
算法复杂度分析：
时间复杂度：O(n) - 遍历字符串一次，每个位置的计算都是常数时间
空间复杂度：O(n) - 使用dp数组存储每个位置的解码方法数

关键点总结：
1. 正确理解dp状态的含义
2. 分情况讨论'*'的所有可能性
3. 注意模运算防止整数溢出
4. 边界条件的处理（空字符串、首字符等）
*/